import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import nmap
import socket
import threading
import queue
from datetime import datetime
import json
import pandas as pd
from pathlib import Path
import logging
import requests
import ssl
import OpenSSL
import whois
import dns.resolver

class VulnerabilityScanner:
    def __init__(self, config_manager):
        self.scanner = nmap.PortScanner()
        self.scan_queue = queue.Queue()
        self.scanning = False
        self.scan_thread = None
        self.vulnerabilities_db = self.load_vulnerabilities_db()
        self.scan_results = []
        self.alert_rules = self.load_alert_rules()
        self.config_manager = config_manager
        
        # Initialize logging
        self.logger = logging.getLogger("VulnerabilityScanner")
    
    def load_vulnerabilities_db(self):
        """Load vulnerability database"""
        try:
            db_path = Path("config/vulnerabilities.json")
            if db_path.exists():
                with open(db_path, 'r') as f:
                    return json.load(f)
            return {
                "common_ports": {
                    "21": "FTP",
                    "22": "SSH",
                    "23": "Telnet",
                    "25": "SMTP",
                    "53": "DNS",
                    "80": "HTTP",
                    "443": "HTTPS",
                    "3306": "MySQL",
                    "3389": "RDP"
                },
                "vulnerabilities": {
                    "weak_ssl": {
                        "description": "Weak SSL/TLS configuration",
                        "severity": "high",
                        "remediation": "Update SSL/TLS configuration to use strong ciphers"
                    },
                    "open_ports": {
                        "description": "Unnecessary open ports",
                        "severity": "medium",
                        "remediation": "Close unused ports"
                    }
                }
            }
        except Exception as e:
            self.logger.error(f"Error loading vulnerability database: {str(e)}")
            return {}
    
    def load_alert_rules(self):
        """Load alert rules"""
        try:
            rules_path = Path("config/alert_rules.json")
            if rules_path.exists():
                with open(rules_path, 'r') as f:
                    return json.load(f)
            return {
                "high_severity": {
                    "condition": "severity == 'high'",
                    "message": "High severity vulnerability detected"
                },
                "multiple_vulns": {
                    "condition": "count > 5",
                    "message": "Multiple vulnerabilities detected"
                }
            }
        except Exception as e:
            self.logger.error(f"Error loading alert rules: {str(e)}")
            return {}
    
    def create_ui(self, parent):
        """Create the vulnerability scanner UI"""
        # Create main frame
        main_frame = ttk.Frame(parent)
        main_frame.pack(expand=True, fill='both', padx=5, pady=5)
        
        # Create control frame
        control_frame = ttk.LabelFrame(main_frame, text="Scan Controls")
        control_frame.pack(fill='x', padx=5, pady=5)
        
        # Target input
        ttk.Label(control_frame, text="Target:").pack(side='left', padx=5)
        self.target_var = tk.StringVar()
        self.target_entry = ttk.Entry(control_frame, textvariable=self.target_var, width=30)
        self.target_entry.pack(side='left', padx=5)
        
        # Scan type selection
        ttk.Label(control_frame, text="Scan Type:").pack(side='left', padx=5)
        self.scan_type_var = tk.StringVar(value="quick")
        scan_types = ttk.Combobox(control_frame, textvariable=self.scan_type_var,
                                values=["quick", "full", "custom"],
                                state="readonly")
        scan_types.pack(side='left', padx=5)
        
        # Custom ports input
        ttk.Label(control_frame, text="Custom Ports:").pack(side='left', padx=5)
        self.ports_var = tk.StringVar()
        self.ports_entry = ttk.Entry(control_frame, textvariable=self.ports_var, width=20)
        self.ports_entry.pack(side='left', padx=5)
        
        # Start scan button
        self.start_button = ttk.Button(control_frame, text="Start Scan", command=self.start_scan)
        self.start_button.pack(side='left', padx=5)
        
        # Create notebook for different views
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(expand=True, fill='both', padx=5, pady=5)
        
        # Create scan results tab
        self.create_scan_results_tab()
        
        # Create vulnerabilities tab
        self.create_vulnerabilities_tab()
        
        # Create alerts tab
        self.create_alerts_tab()
        
        # Add export button
        export_btn = ttk.Button(main_frame, text="Export Results", command=self.export_results)
        export_btn.pack(pady=5, anchor='ne')
    
    def create_scan_results_tab(self):
        """Create the scan results tab"""
        results_frame = ttk.Frame(self.notebook)
        self.notebook.add(results_frame, text='Scan Results')
        
        # Create results tree
        self.results_tree = ttk.Treeview(results_frame, columns=(
            'host', 'port', 'state', 'service', 'version'
        ), show='headings')
        
        # Set column headings
        self.results_tree.heading('host', text='Host')
        self.results_tree.heading('port', text='Port')
        self.results_tree.heading('state', text='State')
        self.results_tree.heading('service', text='Service')
        self.results_tree.heading('version', text='Version')
        
        # Set column widths
        self.results_tree.column('host', width=150)
        self.results_tree.column('port', width=80)
        self.results_tree.column('state', width=80)
        self.results_tree.column('service', width=100)
        self.results_tree.column('version', width=200)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient='vertical', command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Pack results tree
        self.results_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def create_vulnerabilities_tab(self):
        """Create the vulnerabilities tab"""
        vuln_frame = ttk.Frame(self.notebook)
        self.notebook.add(vuln_frame, text='Vulnerabilities')
        
        # Create vulnerabilities tree
        self.vuln_tree = ttk.Treeview(vuln_frame, columns=(
            'host', 'port', 'vulnerability', 'severity', 'remediation'
        ), show='headings')
        
        # Set column headings
        self.vuln_tree.heading('host', text='Host')
        self.vuln_tree.heading('port', text='Port')
        self.vuln_tree.heading('vulnerability', text='Vulnerability')
        self.vuln_tree.heading('severity', text='Severity')
        self.vuln_tree.heading('remediation', text='Remediation')
        
        # Set column widths
        self.vuln_tree.column('host', width=150)
        self.vuln_tree.column('port', width=80)
        self.vuln_tree.column('vulnerability', width=200)
        self.vuln_tree.column('severity', width=80)
        self.vuln_tree.column('remediation', width=300)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(vuln_frame, orient='vertical', command=self.vuln_tree.yview)
        self.vuln_tree.configure(yscrollcommand=scrollbar.set)
        
        # Pack vulnerabilities tree
        self.vuln_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def create_alerts_tab(self):
        """Create the alerts tab"""
        alerts_frame = ttk.Frame(self.notebook)
        self.notebook.add(alerts_frame, text='Alerts')
        
        # Create alerts tree
        self.alerts_tree = ttk.Treeview(alerts_frame, columns=(
            'timestamp', 'severity', 'message', 'details'
        ), show='headings')
        
        # Set column headings
        self.alerts_tree.heading('timestamp', text='Timestamp')
        self.alerts_tree.heading('severity', text='Severity')
        self.alerts_tree.heading('message', text='Message')
        self.alerts_tree.heading('details', text='Details')
        
        # Set column widths
        self.alerts_tree.column('timestamp', width=150)
        self.alerts_tree.column('severity', width=80)
        self.alerts_tree.column('message', width=200)
        self.alerts_tree.column('details', width=300)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(alerts_frame, orient='vertical', command=self.alerts_tree.yview)
        self.alerts_tree.configure(yscrollcommand=scrollbar.set)
        
        # Pack alerts tree
        self.alerts_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
    def start_scan(self):
        """Start vulnerability scan"""
        target = self.target_var.get().strip()
        if not target:
            messagebox.showerror("Error", "Please enter a target")
            return
        
        scan_type = self.scan_type_var.get()
        custom_ports = self.ports_var.get().strip()
        
        # Start scan in a separate thread
        self.scanning = True
        self.start_button.config(state='disabled')
        
        self.scan_thread = threading.Thread(
            target=self.run_scan,
            args=(target, scan_type, custom_ports)
        )
        self.scan_thread.start()
    
    def run_scan(self, target, scan_type, custom_ports):
        """Run the vulnerability scan"""
        try:
            # Clear previous results
            self.results_tree.delete(*self.results_tree.get_children())
            self.vuln_tree.delete(*self.vuln_tree.get_children())
            self.alerts_tree.delete(*self.alerts_tree.get_children())
            
            # Determine scan arguments based on type
            if scan_type == "quick":
                arguments = "-sV -T4"
            elif scan_type == "full":
                arguments = "-sV -sC -O -T4"
            else:  # custom
                if custom_ports:
                    arguments = f"-sV -p{custom_ports} -T4"
                else:
                    arguments = "-sV -T4"
            
            # Run nmap scan
            self.scanner.scan(target, arguments=arguments)
            
            # Process scan results
            for host in self.scanner.all_hosts():
                # Get host information
                hostname = self.get_hostname(host)
                os_info = self.scanner[host].get('osmatch', [{'name': 'Unknown'}])[0]['name']
                
                # Check each open port
                for proto in self.scanner[host].all_protocols():
                    ports = self.scanner[host][proto].keys()
                    for port in ports:
                        port_info = self.scanner[host][proto][port]
                        
                        # Add to results view
                        self.results_tree.insert('', 'end', values=(
                            host,
                            port,
                            port_info['state'],
                            port_info['name'],
                            port_info.get('product', '') + ' ' + port_info.get('version', '')
                        ))
                        
                        # Check for vulnerabilities
                        self.check_vulnerabilities(host, port, port_info)
            
            # Save scan results
            self.save_scan_results()
            
        except Exception as e:
            messagebox.showerror("Error", f"Scan failed: {str(e)}")
        finally:
            self.scanning = False
            self.start_button.config(state='normal')
    
    def get_hostname(self, ip):
        """Get hostname for IP address"""
        try:
            return socket.gethostbyaddr(ip)[0]
        except:
            return ip
    
    def check_vulnerabilities(self, host, port, port_info):
        """Check for vulnerabilities"""
        try:
            # Check SSL/TLS configuration
            if port_info['name'] in ['https', 'ssl', 'tls']:
                self.check_ssl_vulnerabilities(host, port)
            
            # Check for common vulnerabilities
            if port_info['name'] in self.vulnerabilities_db['common_ports'].values():
                self.check_common_vulnerabilities(host, port, port_info)
            
            # Check for version-specific vulnerabilities
            if 'version' in port_info:
                self.check_version_vulnerabilities(host, port, port_info)
            
        except Exception as e:
            self.logger.error(f"Error checking vulnerabilities: {str(e)}")
    
    def check_ssl_vulnerabilities(self, host, port):
        """Check SSL/TLS vulnerabilities"""
        try:
            context = ssl.create_default_context()
            with socket.create_connection((host, port)) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    if cert and 'notAfter' in cert:
                        expiry = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        if expiry < datetime.now():
                            self.add_vulnerability(
                                host, port,
                                "Expired SSL Certificate",
                                "high",
                                "Renew SSL certificate"
                            )
                    
                    # Check cipher strength
                    cipher = ssock.cipher()
                    if cipher and cipher[0] in ['RC4', 'DES', '3DES']:
                        self.add_vulnerability(
                            host, port,
                            "Weak Cipher Suite",
                            "high",
                            "Use strong cipher suites"
                        )
        
        except Exception as e:
            self.logger.error(f"Error checking SSL vulnerabilities: {str(e)}")
    
    def check_common_vulnerabilities(self, host, port, port_info):
        """Check for common vulnerabilities"""
        try:
            # Check for default credentials
            if port_info['name'] in ['ftp', 'ssh', 'telnet']:
                self.add_vulnerability(
                    host, port,
                    "Potential Default Credentials",
                    "medium",
                    "Change default credentials"
                )
            
            # Check for banner information disclosure
            if 'product' in port_info and 'version' in port_info:
                self.add_vulnerability(
                    host, port,
                    "Information Disclosure",
                    "low",
                    "Hide version information"
                )
        
        except Exception as e:
            self.logger.error(f"Error checking common vulnerabilities: {str(e)}")
    
    def check_version_vulnerabilities(self, host, port, port_info):
        """Check for version-specific vulnerabilities"""
        try:
            # Check version against known vulnerabilities
            version = port_info['version']
            if version in self.vulnerabilities_db.get('versions', {}):
                vuln_info = self.vulnerabilities_db['versions'][version]
                self.add_vulnerability(
                    host, port,
                    vuln_info['description'],
                    vuln_info['severity'],
                    vuln_info['remediation']
                )
        
        except Exception as e:
            self.logger.error(f"Error checking version vulnerabilities: {str(e)}")
    
    def add_vulnerability(self, host, port, vulnerability, severity, remediation):
        """Add vulnerability to the view"""
        # Add to vulnerabilities view
        self.vuln_tree.insert('', 'end', values=(
            host,
            port,
            vulnerability,
            severity,
            remediation
        ))
        
        # Check alert rules
        self.check_alerts(host, port, vulnerability, severity)
    
    def check_alerts(self, host, port, vulnerability, severity):
        """Check alert rules"""
        try:
            for rule_name, rule in self.alert_rules.items():
                if self.evaluate_rule(rule, host, port, vulnerability, severity):
                    # Add to alerts view
                    self.alerts_tree.insert('', 'end', values=(
                        datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        severity,
                        rule['message'],
                        f"Host: {host}, Port: {port}, Vulnerability: {vulnerability}"
                    ))
        
        except Exception as e:
            self.logger.error(f"Error checking alerts: {str(e)}")
    
    def evaluate_rule(self, rule, host, port, vulnerability, severity):
        """Evaluate an alert rule"""
        try:
            if rule['condition'] == "severity == 'high'":
                return severity == 'high'
            elif rule['condition'] == "count > 5":
                # Count vulnerabilities for this host
                count = len([item for item in self.vuln_tree.get_children()
                           if self.vuln_tree.item(item)['values'][0] == host])
                return count > 5
            return False
        
        except Exception as e:
            self.logger.error(f"Error evaluating rule: {str(e)}")
            return False
    
    def save_scan_results(self):
        """Save scan results to file"""
        try:
            results_dir = Path("reports/vulnerability_scans")
            results_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = results_dir / f"scan_results_{timestamp}.json"
            
            results = {
                'scan_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'target': self.target_var.get(),
                'scan_type': self.scan_type_var.get(),
                'results': []
            }
            
            # Save scan results
            for item in self.results_tree.get_children():
                values = self.results_tree.item(item)['values']
                results['results'].append({
                    'host': values[0],
                    'port': values[1],
                    'state': values[2],
                    'service': values[3],
                    'version': values[4]
                })
            
            # Save vulnerabilities
            results['vulnerabilities'] = []
            for item in self.vuln_tree.get_children():
                values = self.vuln_tree.item(item)['values']
                results['vulnerabilities'].append({
                    'host': values[0],
                    'port': values[1],
                    'vulnerability': values[2],
                    'severity': values[3],
                    'remediation': values[4]
                })
            
            with open(filename, 'w') as f:
                json.dump(results, f, indent=4)
            
        except Exception as e:
            self.logger.error(f"Error saving scan results: {str(e)}")
    
    def export_results(self):
        """Export scan results to CSV"""
        try:
            filename = filedialog.asksaveasfilename(
                defaultextension='.csv',
                filetypes=[('CSV files', '*.csv'), ('All files', '*.*')],
                title='Save Scan Results As...'
            )
            
            if filename:
                # Export scan results
                results_data = []
                for item in self.results_tree.get_children():
                    results_data.append(self.results_tree.item(item)['values'])
                
                results_df = pd.DataFrame(results_data,
                                        columns=['Host', 'Port', 'State', 'Service', 'Version'])
                results_df.to_csv(f"{filename}_results.csv", index=False)
                
                # Export vulnerabilities
                vuln_data = []
                for item in self.vuln_tree.get_children():
                    vuln_data.append(self.vuln_tree.item(item)['values'])
                
                vuln_df = pd.DataFrame(vuln_data,
                                     columns=['Host', 'Port', 'Vulnerability', 'Severity', 'Remediation'])
                vuln_df.to_csv(f"{filename}_vulnerabilities.csv", index=False)
                
                messagebox.showinfo("Success", f"Scan results exported to {filename}")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export results: {str(e)}")
    
    def update_ui(self):
        """Update the UI components"""
        pass  # No real-time updates needed for this module 